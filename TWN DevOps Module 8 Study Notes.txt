what is Docker?
-> Docker is an open-source containerisation platform
-> enables developers to package applications into containers
-> containers existed already before Docker but Docker made containers popular

what is a container?
-> a way to package an application with all the necessary dependencies and configuration
-> portable standardised artifact for development, shipment, and deployment
-> makes development and deployment more efficient

where container artifacts are hosted:
-> hosted in container repositories (both private and public repositories)
-> public repository for Docker: DockerHub

installation process differs depending on the OS environment:
-> many steps where something could go wrong
-> single command installation for simplicity

easily run the same application with 2 different versions

application development before and after Docker:
before containers:
-> own isolated environment
-> configuration on the server needed
-> dependency version conflicts
-> textual guide for deployment
-> potential misunderstandings

after containers:
-> packaged with all needed configurations
-> no environment configuration needed on the server (except for Container Runtime)

application deployment before and after Docker:
before containers:
-> developers and operations teams work together to package the application

after containers:
-> no environment configuration needed on server (except Container Runtime)
-> Docker is the most popular container technology

other containers:
-> Docker images become containers at runtime
-> actually starts the application within a running environment defined in the image
-> virtual file system
-> port binding to talk to the application running inside the container

Docker image vs Docker container:
-> Docker image: a non-running artifact, which consists of several layers. typically includes a base Linux image and the application image on top
-> Docker container: a running instance of a Docker image

containers vs virtual machines:
-> both are virtualisation tools
-> virtual machines: full OS copy, abstraction at hardware layer
-> containers: abstraction at the app layer, with multiple containers sharing the OS kernel

key differences:
-> size: Docker image is much smaller
-> speed: Docker containers start and run much faster
-> compatibility: virtual machines can run on any OS host, while you canâ€™t run Linux containers on a Windows host (unless using Docker Desktop)

pulling images and managing images & containers

Docker architecture & components - 1:
-> interacting with Docker server through command line interface
-> managing container lifecycle

Docker architecture & components - 2:
-> persisting data and configuring network for container communication

Docker architecture & components - 3:
-> Docker includes multiple functionalities in one application

alternatives (if you only need a container runtime):
-> Docker Desktop (Mac + Windows) and Linux has native support

main Docker commands:
-> `docker run`: creates a container from an image
-> `docker pull`: pulls images from the Docker repository
-> `docker start`: starts one or more stopped containers
-> `docker stop`: stops a running container
-> `docker images`: lists all locally stored Docker images
-> `docker ps`: lists running containers
-> `docker ps -a`: shows all running and exited containers
-> `docker logs`: fetch logs of a container
-> `docker exec -it`: creates a new bash session inside the container

debug commands:
-> container port: port mapping to avoid conflicts

port mapping:
-> container port = port used inside the container
-> host port = port on the host machine

Docker Compose - 1:
-> tool to define and run multiple Docker containers
-> YAML file for configuring application services
-> Docker Compose automatically creates a common Docker network for containers

Docker Compose - 2:
-> example `docker-compose.yaml` file

Dockerfile - 1:
-> simple text file that consists of instructions to build Docker images

Dockerfile commands:
-> Dockerfile builds images by executing instructions

Dockerfile - 2:
-> the build context is the set of files at a specified location
-> commonly starts with an existing base image

Dockerfile - 3:
-> used in CI/CD pipelines to build Docker image artifacts
-> Docker image can be pushed to repositories or pulled locally

private Docker repository - 1:
-> private Docker registries (e.g., AWS ECR) versus public repositories like DockerHub

private Docker repository - 2:
-> public images (e.g., MySQL, MongoDB) from public Docker repositories
-> private images (e.g., internal applications) from private Docker repositories

deploying Docker containers on a remote server:
-> pull from both private and public repositories

Docker volumes - 1:
-> volumes persist data generated by Docker containers
-> important for stateful applications like databases

why are volumes needed for persistence?
-> data is stored on the virtual file system inside the container, so when the container is removed, data is lost

Docker volumes - 2:
-> virtual file system inside the container
-> folder on host system mounted into the container's virtual file system

Docker volumes types:
-> host volumes, anonymous volumes, named volumes

Docker volumes - 3:
-> use volume mounts for persistence and managing data

Docker volumes - 4:
-> define volumes in a `docker-compose.yaml` file for consistent data storage

Docker best practices - 1:
-> use trusted Docker images to avoid malware
-> use specific image versions for consistency
-> optimise image size by using minimal base images like Alpine

Docker best practices - 2:
-> use least privileged user accounts for containers
-> scan images for vulnerabilities
-> avoid leaking sensitive information in Docker images

build automation & CI/CD with Jenkins:
-> automates building, testing, compiling, and deploying artifacts

what is build automation?
-> automates source code retrieval, test execution, compiling, and Docker image builds

build automation and CI/CD are central to DevOps:
-> automates the software release cycle to "release early and often"

what is CI/CD?
-> continuous integration (CI): builds, tests, and merges code continuously
-> continuous deployment (CD): automates deploying artifacts to different environments

Jenkins: industry's most used CI/CD tool
-> integrates with Docker, build tools, repositories, deployment servers through plugins

introduction to Jenkins:
-> Jenkins is software that automates builds, tests, and deployments
-> you can configure Jenkins to execute tasks using plugins

Jenkins installation:
-> can be installed as a Docker container or directly on the operating system

Jenkins job types - 1:
-> build jobs orchestrate the build process
-> "pipeline" jobs are suitable for complex workflows, including CI/CD pipelines

Jenkins job types - 2:
-> freestyle jobs are simpler for individual tasks, while pipeline jobs offer flexibility
-> "pipeline as code" is the industry best practice

Jenkinsfile syntax:
-> declarative pipeline for simpler use, and scripted pipeline for more advanced scripting
-> define environment variables, parameters, and tools in the Jenkinsfile

Jenkins shared library:
-> share common code across projects to reduce duplication and simplify pipeline management

triggering Jenkins jobs:
-> manually or automatically trigger Jenkins jobs with Git webhooks or scheduling

software versioning:
-> versioning is essential for applications
-> versioning typically follows: major, minor, patch versions

dynamically increment application version:
-> build tools can automatically increment version numbers

best practices for Jenkins pipelines:
-> use pipeline as code and store Jenkinsfile in Git repositories
-> use automatic versioning for better consistency
-> use shared libraries to manage common tasks across projects
